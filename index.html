<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Encrypted Website Loader</title>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    iframe {
      border: 0;
    }
  </style>
  <script>
    // Function to generate UUID v4
    function generateUUID() {
      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }

    // Function to convert string to ArrayBuffer
    function str2ab(str) {
      const encoder = new TextEncoder();
      return encoder.encode(str);
    }

    // Function to convert ArrayBuffer to string
    function ab2str(buf) {
      const decoder = new TextDecoder();
      return decoder.decode(buf);
    }

    // Function to derive encryption key from UUID
    async function getKey(uuid) {
      const keyMaterial = await crypto.subtle.importKey(
        "raw",
        str2ab(uuid),
        { name: "PBKDF2" },
        false,
        ["deriveBits", "deriveKey"]
      );

      return crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt: str2ab("salt"),
          iterations: 100000,
          hash: "SHA-256"
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
    }

    // Function to decrypt binary data
    // If `asArrayBuffer` is true, return the raw ArrayBuffer of decrypted bytes
    // Optionally provide a `cryptoKey` to use; otherwise derive from `userUUID`.
    async function decryptMessage(encryptedData, asArrayBuffer = false, cryptoKey) {
      if (!cryptoKey) throw new Error('decryptMessage requires a cryptoKey parameter');
      const key = cryptoKey;

      // First 12 bytes are IV, rest is ciphertext
      const iv = new Uint8Array(encryptedData.slice(0, 12));
      const data = new Uint8Array(encryptedData.slice(12));

      const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: iv },
        key,
        data
      );
      if (asArrayBuffer) return decrypted;
      return ab2str(decrypted);
    }

    // Function to fetch and decrypt a file
    // Fetch and decrypt. If `asArrayBuffer` is true, the decrypted result is returned as an ArrayBuffer.
    // Optional `cryptoKey` can be provided to use a specific key for decryption.
    async function fetchAndDecrypt(filename, asArrayBuffer = false, cryptoKey) {
      if (!cryptoKey) throw new Error('fetchAndDecrypt requires a cryptoKey parameter');
      const response = await fetch('encrypted/' + filename);
      const arrayBuffer = await response.arrayBuffer();
      return await decryptMessage(arrayBuffer, asArrayBuffer, cryptoKey);
    }

    // Helper: Convert decrypted font ArrayBuffer to base64 data URL to avoid blob font restrictions in some browsers
    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const chunkSize = 0x8000; // arbitrary chunk size
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    }

    // Helper: compute SHA-256 and return filesystem-safe base64url (no padding)
    async function sha256Base64Url(str) {
      const hash = await crypto.subtle.digest('SHA-256', str2ab(str));
      const bytes = new Uint8Array(hash);
      let binary = '';
      for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
      const b64 = btoa(binary);
      return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    // Helper: compute SHA-256 over user key and return base64url
    async function sha256Base64UrlBytes(userKey) {
      const arrayBuffer = await crypto.subtle.exportKey('raw', userKey);
      const hash = await crypto.subtle.digest('SHA-256', arrayBuffer);
      const bytes = new Uint8Array(hash);
      let binary = '';
      for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
      const b64 = btoa(binary);
      return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    // Function to create a blob URL for decrypted content
    function createBlobUrl(content, type) {
      const blob = new Blob([content], { type });
      return URL.createObjectURL(blob);
    }

    // Function to load the decrypted website
    async function loadDecryptedWebsite() {
      try {
        // Obtain the user's decryption key (derived from UUID)
        const userKey = await getKey(userUUID);
        // Derive filename for per-user keyfile by hashing the raw derived key bytes
        const userHash = await sha256Base64UrlBytes(userKey);
        const keyFilename = `keys/${userHash}.encrypted`;

        // Fetch and decrypt the per-user keyfile (this yields raw AES key bytes)
        const keyFileArray = await fetchAndDecrypt(keyFilename, true, userKey);
        // Import raw bytes as AES-GCM CryptoKey for content decryption
        const contentKey = await crypto.subtle.importKey(
          'raw',
          keyFileArray,
          { name: 'AES-GCM' },
          true,
          ['encrypt', 'decrypt']
        );

        // Decrypt all necessary site files with the derived content key
        const htmlContent = await fetchAndDecrypt('html/index.html.encrypted', false, contentKey);
        const cssContent = await fetchAndDecrypt('html/style.css.encrypted', false, contentKey);
        const jsContent = await fetchAndDecrypt('html/script.js.encrypted', false, contentKey);
        const miniArray = await fetchAndDecrypt('html/mini.json.encrypted', true, contentKey);
        const arrowLeftArray = await fetchAndDecrypt('html/assets/arrow-left.svg.encrypted', true, contentKey);
        const arrowRightArray = await fetchAndDecrypt('html/assets/arrow-right.svg.encrypted', true, contentKey);
        const logoArray = await fetchAndDecrypt('html/assets/logo.svg.encrypted', true, contentKey);
        const pencilArray = await fetchAndDecrypt('html/assets/pencil-blue.svg.encrypted', true, contentKey);
        const settingsArray = await fetchAndDecrypt('html/assets/settings-gear.svg.encrypted', true, contentKey);
        const fontArray = await fetchAndDecrypt('html/fonts/font.woff2.encrypted', true, contentKey);

        // Create blob URLs for other files (decrypted with the derived content key)
        const miniUrl = createBlobUrl(miniArray, 'application/json');
        const arrowLeftUrl = createBlobUrl(arrowLeftArray, 'image/svg+xml');
        const arrowRightUrl = createBlobUrl(arrowRightArray, 'image/svg+xml');
        const logoUrl = createBlobUrl(logoArray, 'image/svg+xml');
        const pencilUrl = createBlobUrl(pencilArray, 'image/svg+xml');
        const settingsUrl = createBlobUrl(settingsArray, 'image/svg+xml');

        // For fonts we request raw ArrayBuffer so we can embed as data: URI (avoids Firefox blob font sanitizer)
        const fontBase64 = arrayBufferToBase64(fontArray);
        const fontDataUrl = 'data:font/woff2;base64,' + fontBase64;
        // Special case: CSS needs the font replaced (use data: URI)
        const cssContentModified = cssContent.replaceAll('fonts/font.woff2', fontDataUrl);
        const cssUrl = createBlobUrl(cssContentModified, 'text/css');

        // Special case: JS needs the mini.json replaced
        const jsContentModified = jsContent.replaceAll('mini.json', miniUrl);
        const jsUrl = createBlobUrl(jsContentModified, 'text/javascript');

        // Modify HTML to use blob URLs for resources
        const modifiedHtml = htmlContent
          .replaceAll('style.css', cssUrl)
          .replaceAll('script.js', jsUrl)
          .replaceAll('mini.json', miniUrl)
          .replaceAll('assets/arrow-left.svg', arrowLeftUrl)
          .replaceAll('assets/arrow-right.svg', arrowRightUrl)
          .replaceAll('assets/logo.svg', logoUrl)
          .replaceAll('assets/pencil-blue.svg', pencilUrl)
          .replaceAll('assets/settings-gear.svg', settingsUrl);

        // Create blob URL for the HTML
        const htmlUrl = createBlobUrl(modifiedHtml, 'text/html');

        // Create an iframe to host the decrypted content
        const iframe = document.createElement('iframe');
        iframe.style.width = '100%';
        iframe.style.height = '100vh';
        iframe.style.border = 'none';
        // Load the decrypted website in the iframe
        iframe.src = htmlUrl;
        document.body.innerHTML = '';
        document.body.appendChild(iframe);

      } catch (error) {
        console.error('Error loading decrypted website:', error);
        alert('Error loading decrypted website. Make sure your UUID is correct.');
      }
    }

    // Check for existing UUID or generate new one
    let userUUID = localStorage.getItem('userUUID');
    if (!userUUID) {
      userUUID = generateUUID();
      localStorage.setItem('userUUID', userUUID);
    }

    // Wait for DOM to load
    window.addEventListener('DOMContentLoaded', () => {
      document.getElementById('uuid').textContent = userUUID;
    });
  </script>
  <style>
    form {
      margin: 20px 0;
    }

    input[type="text"] {
      width: 300px;
      padding: 5px;
    }
  </style>
</head>

<body>
  <div id="loader" style="text-align: center; padding: 50px;">
    <h2>Loading encrypted website...</h2>
    <p>UUID: <span id="uuid"></span></p>
  </div>
  <script>
    // Add event listeners once DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('uuid').textContent = userUUID;
      // Start loading the decrypted website
      loadDecryptedWebsite();
    });
  </script>
</body>

</html>